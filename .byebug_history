continue
error.error.full_messages
error.full_messages
error.full_message
error
error.methods
error.errors
error
quit
continue
quit
continue
object.project.tax_rate
object.project
object
continue
budget_items
self
continue
new_budget_item.project
new_budget_item
continue
current_user
continue
current_user
continue
current_user
continue
params
continue
subject
user.email
user
params[:user]
params
continue
object.budget_items.all.map{|item| item.total}.sum
object.budget_items.all.map{|item| item.total}
object.budget_items.all.total
object.budget_items.all
object.budget_items.pluck(:total)
object.budget_items.first.total
object.budget_item.first.total
object
quit
continue
project.tax_rate.to_f
project.tax_rate
project
taxed
continue
taxed
continue
taxed
next
taxed
next
taxed
continue
exit
continue
object.unit_quantity * object.unit_cost
object.unit_quatity * object.unit_cost
object
continue
10.times do 
project_data
continue
array_e[0].length
array_e[0]
array_e[1]
array_e
keys
continue
keys.each_index.reject{|x| keys[x].include?("Division")}
continue
array
scrape.create_divisions
scrape = Scraper.new
continue
scrape.create_divisions
scrape.get_data_array
scrape.create_divisions
scrap.create_divisions
scrape = Scraper.new
continue
indexes
array
indexes.count
indexes
array.flatten.select{|k, v| k.include?('Division')}
continue
array.flatten
trow
array.flatten
trow
array.flatten
array
td
continue
trow
keys.each_index.split{|x| keys[x].include?("Division")}
indexes.split{|i| array[i]}
indexes.map{|i| array[i]}
array
indexes.map{|i| array.split{|_,a| a[i]}}
indexes.map{|i| array.split{
indexes
continue
keys.each_index.select{|x| keys[x].include?("Division")}
array[1..32]
array[1..31]
array[1..31
keys.each_index.select{|x| keys[x].include?("Division")}
keys.each_index.select{|x| keys[x] == "Division"}
keys.each_with_index.map{|x,i| x == "Division"? i : nil}.c
array.each_with_index.map{|x,i| x == "Division"? i : nil}.compact
arrayeach_with_index.map{|x,i| x == "Division"? i : nil}.compact
keys.index{|a| a.include?("Division")}
array.index{|a| a.include?("Division")}
array
keys
divs
divisions
keys
continue
keys
continue
divisions
array.length
values.count
values.length
values
array
divs
continue
divisions.map do |div|
continue
array.select{|k, v| k.include?('Division')}
array.select{|k| k.include?('Division')}
array.each_index.map{|k| k.select{|a| a.include?('Division')}}
array.each_index.select{|k| array[k].include?('Division')}
array.each_index.select{|k| k.include?('Division')}
array.each_index.select{|k, v| k.include?('Division')}
array.select{|k, v| k.include?('Division')}
array.reject{|k, v| k.include?('Division')}
array
continue
array
continue
keys.zip values
Array[keys.zip values]
hash.reject{|k, v| k.include?('Division')}
hash.select{|k, v| k.include?('Division')}
hash.select{|k, v| ("Division 14-").include?(k)}
hash.select{|k, v| ("Division").include?(k)}
hash.select{|k, v| keys.include?('Division')}
hash.select{|k| keys.include?('Division')}
hash.length
hash
continue
array_o
array
continue
array
continue
array_e.map |a| do
array_e.map{|a| "Division " + a if a.length === 3 && a.include?('-') else return  a
array_e.map{|a| "Division " + a if a.length === 3 && a.include?('-') else a}
array_e.collect{|a| "Division " + a if a.length === 3 && a.include?('-') else a}
array_e.collect{|a| "Division " + a if a.length === 3 && a.include?('-')}
array_e
array_o
array_o.length
array_e.length
array_e.length === array_o.length
array_e.length = array_o.length
array_e
continue
doc.css('th').text
thead
trow.values_at(* trow.each_index.select {|i| i.odd?})
trow.values_at(* trow.each_index.select {|i| i.even?})
trow.values_at(* a.each_index.select {|i| i.even?})
trow
array.each_slice(2)
thead
array.drop(2)
array === trow
array
continue
array
trow
continue
trow
continue
thead.split("Division").collect(&:strip)
thead.split("Division")
thead.split("0")
thead
continue
thead
continue
th
continue
array.drop(2)
array.slice(1)
array.count
array
continue
doc.css('table').text.split("\n").collect(&:strip).reject{|a| a.empty?}
doc.css('table').text.split("\n").collect(&:strip)
doc.css('table').text.split("\n")
doc.css('table').text
doc
continue
JSON.parse(body)
body
continue
table
continue
doc
scrape = Scraper.new
scrape
continue
array.any?(roll)
array.any(roll)
roll
array = ["PM", "Estimator", "Superintendent"]
